// Во многих языках программирования существует интересная функция flip. Её необычность заключается в том, что единственная цель этой функции — это преобразовать другую функцию так, чтобы порядок её аргументов был обратным.

// Например, у нас может быть функция pow, которая возводит первый аргумент в степень второго. flip вернет нам новую функцию, у которой первый аргумент — это степень, а второй — это число, которое нужно возводить в эту степень.

// Эта функция бывает очень полезна при активной работе с функциями высшего порядка, она часто упрощает возможность комбинировать функции между собой.

// solution.js
// Реализуйте и экспортируйте по умолчанию функцию flip. Данная версия flip работает только с функциями принимающими два аргумента.

// // subtraction
// const sub = (a, b) => a - b;
// const reverseSub = flip(sub);

// sub(5, 3); // 2
// reverseSub(5, 3); // -2

// // exponentiation
// const wop = flip(Math.pow);

// Math.pow(1, 2); // 1
// wop(1, 2); // 2

// Math.pow(3, 2); // 9
// wop(3, 2); // 8

//test
const f1 = (a, b) => a ** b;
console.log(f1(2, 3));

const f2 = (a, b) => a - b;
console.log(f2(2, 3));

const f3 = (a, b) => a / b;
console.log(f3(2, 3));
//test


// me decision --------------------------------------
const flip = foo => (b, a) => foo(a, b);
// me decision --------------------------------------

//test
const revers1 = flip(f1);

const revers2 = flip(f2);

const revers3 = flip(f3);

console.log(revers1(2, 3));
console.log(revers2(2, 3));
console.log(revers3(2, 3));
//test

// decision teacher from hexlet-------------------------------------
// BEGIN
//         export default f => (a, b) => f(b, a);
// END
// decision teacher from hexlet-------------------------------------